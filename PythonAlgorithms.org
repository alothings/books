#+STARTUP: hidestars
#+STARTUP: indent

* Data Structures and Algorithms in Python
- www.wiley.com/college/goodrich

** DONE 1 Python Primer
*** 1.2 Objects in Python
- Python is an object-oriented language and *classes* form the basis for all data types.
**** Identifiers, Objects, and Assignment
  temperature = 98.6
- temperature is the *identifier*, aka name.
- the *identifier* is associated with the object float with the value of 98.6
***** Identifiers
Are case-sensitive
Identifiers are like reference variable in Java or pointer variable in C++.
Each identifier is associated with the memory address of the object.

- Note python uses *alias*, so original = temperature makes original point to the same object as temperature.
***** Accessors:
- Methods of a class that return information about the state of object, but do not modify it.
***** Mutators (or update methods):
- DO change the state of an object (like sort())
***** Sequences: Collection of values in which order is significant
- list: stores sequence of references to its elements. Dynamic
- tuples: like lists but immutable
***** Set and Frozenset classes
- set: represents mathematical notion of a set. Collection of elements without duplicates nor order. Optimized to check if element is contained. Can only contain instances of *immutable* types.
- frozenset: is a set thats immutable.
***** dict

*** 1.3 Expressions, Operators, and Precedence
- / true division
- // integer division
- and & or are short circuit (don't need to eval second operand)

Note that extened assignment operators can mutate elements without reassigning. For isntance
alpha = [1,2,3]
beta = alpha          # alias for alpha
beta += [4,5]         # extends original
beta = beta + [6,7]   # reassings beta to a new list 
print(alpha)          # outputs: [1,2,3,4,5]
**** Bitwise Operators
- ~ bitwise complement
- & bitwise and
- | bitwise or
- ^ bitwise exclusive-or
- << shift bits left, filling with zeros
- >> shift bits to right, filling with sign bit
**** Sequence Operators
Each of pythons built-in sequence types str,stuple,list support:
- s[j]
- s[start:stop] which slices [start,stop)
- s[start:stop:step] 
- s + t concatenates
- k * s shortand for s + s .. + s (k times)
- val in s: check containment
- val not in s: check non-containment
**** Operators for Sets and Dictionaries
- key *in* s, key *not in* s
- ==, !=, <=, >=, | (uniont), & (intersection)
- s1 - s2 set of elements in s1 but not in s2
- s1 ^ s1 set of elements in only s1 or s2
  
*** 1.4 Control Flow
- if, elif, else.
- while
- for element in iterable, for i in range()
- break, continue

*** 1.5 Functions
- Function: describe traditional, stateless function invoked without the context of a class or instance. Such as sorted(data)
- Method: a member function invoked upon a specific object, such as data.sort()
When a function is called, Python creates a dedicated *activation record* that stores info of the current call, including the *namespace* to manage all *identifiers* that have a local scope.
**** 1.5.1 Information Passing
- formal parameters: parameters describing input
- actual parameters: object sent when functin is called.
- Mutable Parameters: makes it possible for the body of a function to alter the object passed as an actual parameter.
#+BEGIN_SRC python
def scale(data, factor):
  for j in range(len(data)):
    data[j] *= factor
#+END_SRC
- The code above shows that the body of the function can modify the object. Because data (the formal parameter) works as an alias for the actual parameter.
- Python is polymorphic, also functions can declare one or more default values for parameters. Like 
  - def foo(a, b=15, c=27)
- Remember: In python, functions are first-class objects(1.10).
**** 1.5.2 Python's built-in functions
Chart on page 29

*** 1.6 Simple I/O
- print(a, b, .., sep=":"): can modify separator
- input(): optional string, always returns string. Do something like:
  + year = int(input('In what year were you born'))
**** 1.6.2 Files
fp = open('sample.txt') returns a proxy for interactions. Allows read-only access to file.
r: reading
w: writing (causing existing file to be overwritten)
a: appending to existing file
rb, wb: working with binary files 
***** Reading from file
To access a file, beging with creating a proxy with open:
- fp = open('sample.txt')

Optional second parameter: r (reading), w (writing), a (appending), rb (read binary), wb (write binary)

most basic command for reading via proxy is read method.
- fp.read() or fp.read(k): return remaining contents, or return next k bytes
- fp.readline() return corrent line
- fp.readlines() return all lines
- fp.seek(k) change the current position to be at the kth byte
- fp.tell() return current position as byte-offset from start
- fp.write(string), fp.writelines(seq)

*** 1.7 Exception Handling
Page 33
- raise: raise ValueError('wrong'): throws exception
Catching Exceptions: "Look before you leap."
- if y != 0: ration = x/y, else do something else.
Or "Easier ask for forgiveness than permission"
- try: ratio = x/y, except ZeroDivisionError: do something else

*** 1.8 Iterators and Generators
**** Iterators
They are used to allow objects to be iterable, like: 
- for element in iterable:
    do something..

*Iterator*: object that manages an iteration through a series of values. So if i identifies an iterator object, then calling next(i) produces the next element until geting StopIteration exception.

*Iterable*: object, obj, that produces an iterator via the syntax iter(obj)

By this definitions:
- _instance_ of a _list_ is an iterable, but not an iterator.
  however, an iterator object can be produced with syntax i=iter(data), and then each call to next(i) returns an element of that list.
- It is possible to create multiple *iterators* from the same iterable object. Note iterator does not store its own copy of the iterable object. So if it is modified while iterating, it will report the updated contents of the list.

**** Generators
Most convenient technique for creating *iterators* in Python is by using *generators*.
A *generator* is just a function that instead of having a *return* statement, it has a *yield* statement.
#+BEGIN_SRC python
def factors(n)            # traditonal f to compute factors
  results = []
  for k in range(1, n+1):
    if n % k == 0:
      results.append(k)   # add k to list
  return results          # return entire list

#+END_SRC

#+BEGIN_SRC python
def factors(n):           # generator that computes factors
  for k in range(1, n+1):
    if n % k == 0:        # instead of appending to list
      yield k             # yield each iteam k
#+END_SRC

Then that can be used in a loop like:

#+BEGIN_SRC python
for factor in factors(100):
  do something
#+END_SRC

*** 1.9 Python Conveniences  
**** Support for *conditional expression* 
  + expression1 *if* condition *else* expression2

**** *comprehension syntax* like *list comprehension*
- [expression *for* value *in* iterable *if* condition]
- [expression *for* value *in* iterable]
Examples:
squares = [ k*k for k in range(1, n+1)]

- [ k*k for k in range(1, n+1) ]      list comprehension
- { k*k for k in range(1, n+1) }      set 
- ( k*k for k in range(1, n+1) )      generator
- { k : k*k for k in range(1, n+1) }  dictionary
 
**** Packagin/Unpackaging sequences
Like: a,b,c = range(7,10)
Simultaneous assignments j,k = k,j  

*** 1.10 Scopes
**** First-class Objects
Are instances of a type that can be:
- assigned to identifier,
- passed as a parameter,
- returned by a function.
In python, all data types like int and list are first-class types, but additionally *functions* are as well. Example:
+ scream = print
+ scream("Hello")

*** 1.11 Modules and Import Statements
Example: from math import pi, sqrt or import math, in which case the use should be math.pi.

- Use: if __name__ == '__main__':
To place commands that will be executed if module is directly invoked as script, but not when it is imported as a module. This is specially ised for *unit tests*

Existing modules: array, collections, copy, math, os, random, re, sys, time, etc..

** DONE 2 OOP
CLOSED: [2017-05-04 Thu 15:57]
In OO Paradigm, main actors are *objects*.
Each *object* is an *instance* of a *class*.
Class has:
- Instance variables (aka data members)
- Methods (member functions)
  
*** 2.1 Goals, Principles, and Patterns
**** 2.1.1 OO Design Goals
***** Robustness   : Capable of handling unexpected inputs
***** Adaptability : Aka Evolvability, so it can run withminimal change on different hardward or OS
***** Reusability  : Same code should be usable as a component of different systems.

**** 2.1.2 OO Design Principles
***** Modularity   : Helps support Robustness and Reusability. 
Different components of a software system are divided into separate functional units

***** Abstraction  : To distill a complicated system down to its most fundamental parts
Uses ADTs (abstract data types). ADT specifies what and not how. ADT is a mathematical model, it specifies:
- data stored
- operations supported on such data
- types of parameters of the operations
Set of behaviors supported by ADT = *public interface*

In Python, supports ABC (abstract base class): ABC cannot be instantiated, but defines methods that all implementations of the abstraction must have.
Concrete classes that inherit ABC

***** Encapsulation: Diff components of system should not reveal internat details of their implementations
Pros: Gives programmer freedom to implement the details of a component without concern that other programmers will be writing code dependent on those internal components.
Yields: Robustness and adaptability. Sincea public interface for such component will need to be created.

In Python, variables with underscore are nonpublic: (_secret)

**** 2.1.3 Design Patterns
Design pattern = Describes a solution to a "typical" software design problem. Provides general template for solution for many diff situations.

Researchers have developed a variety of organizational concepts and methodologies for designing quality OO Software.

***** Examples of ALgorithm Design Patterns:
- Recursion
- Amortization
- Divide and conquer
- Prune-and-search aka Decrease and conquer
- Brute force
- Dynamic Programming
- Greedy method

***** Examples of Engineering Design Patterns:
- Iterator
- Adapter
- Position
- Composition
- Template method
- Locator
- Factory method
  
*** 2.2 Software Development
Traditional steps: Design, IMplementation, Testing & Debugging

**** 2.2.1 Design
Helpful rules to determine how to design classes:
- Responsabilities: Divide work into different actors, each with their own responsability. They are the classes
- Independence: Define work of each class to be as independent from other classes as possible. Subdivide responsabilities between classes to make the autonomous.
- Behaviors: Define behaviors carefully and precisely, so consequences are well udnerstood by other classes.

Notes:
- Can use UML to express the design. Like class diagram.
- An intermediate step before implementations: Pseudo-code.

**** 2.2.3 Coding style and Documentation
Encapsulation: private identifiers being with _underscore
Docstring """ for documentation.

**** 2.2.4 Testing and Debugging
Perform unit test in:
- if __name__ == '__main__': 

*** 2.3 Class Definition
**** 2.3.2 Operator Overloading and Python's Special Methods
**** 2.3.4 Iterators

#+BEGIN_SRC python
class SequenceIterator:
  def __init__(self, sequence):
    self._seq = sequence
    self._k = -1

  def __next__(self):
    self._k += 1
    if self._k < len(self._seq):
      return(self._seq[self._k])    # return the data element
    else:
      raise StopIteration()

 def __iter__(self):
  return self             # By convention, always return self

#+END_SRC

*** 2.4 Inheritance
**** 2.4.1 Extending class
**** 2.4.3 Abstract Base Classes 

*** 2.5 Namespaces and Object-Orientation
**** 2.5.1 Instance and Class namespaces
**** 2.5.2 Name Resolution & Dunamic Dispatch

*** 2.6 Shallow and Deep Copying

** DONE 3 Algorithm Analysis
Data structure: systematic way of organizing and accessing data
Algorithm: step-by-step procedure for performing some task
*** 3.1 Experimental Studies
Determining the elapsed time by recording in it just before and just after the algorithm occurs:
- start_time = time() # record starting time
- end_time = time()   # record the ending time
- elapsed = end_time - start_time
This method is not practical for all instances, so need to find a different approach. Maybe time as a function of input?

*** 3.2 The seven functions used in this Book
Seven most important functions used in the analysis of alogirhtms. 
- The Constant Function: f(n) = c
- The Logarithm Function: x = logb(n) iff b^x = n
- Linear: f(n) = n
- N-log-N: f(n) = nlogn, 
- Quadratic: f(n) = n^2
- Cubic and other Polynomials: f(n) = n^3
- Exponential Function: b^n

*** 3.3 Asymptotic Analysis
Big-Oh notation. 

*** 3.4 Simple Justification Techniques
Technique to make claims about an algorith. Such is showing it is correct or that it runs fast.
- *By example* (or by counter exampleto negate something)
- *The Contra Attack*: Contrapositive and COntradiction. Contrapositive method is like looking through a negative mirror. To justyfy "if p is true, then q is true", we can establish that "if q is not true, then p is not true". Rememer *DeMorgan's Law*. 
- *Induction and Loop Variants*: showing q(n) is true for n=1, then inductive step is true for n>k, namely, show "if q(j) is true for al j<n, then q(n) is true"

** DONE 4 Recursion
Important technique in the study of data structures and algorithms. Will be used in chapters 8 and 12 (Trees and Sorting and Selection)
*** 4.1 Ilustrative Examples
**** Factorial Function: classic math function naturally recursive
Definition:
- n! = 1                      , if n = 0
     = n*(n-1)*(n-2)...2*1    , if n <= 1
which can also be written as
- n! = 1                      , if n = 0      # base case
     = n*(n-1)!               , if n <= 1

In Python, each time a function is called, a structure known as *activation reccord* or *frame* is created to store info on the progress of that invocation. 
During recursion, the former call is suspended and its  *activation record* stores the place that will resume when the nested function is done. There is a different activation record for each active call.

**** English Ruler: has recursive pattern example of fractal struct.
Drawing the markings of a typical English ruler. Like:
----0
-
--
-
---
-
--
-
----1

It is a simple example of a fractal, a shape that has a self-recursive structure at varios levels of magnification.

**** Binary Search: duh
**** File System: used to explore and manage file systems
*** 4.2 Analyzing Recursive Algorithms
*** 4.3 Recursion run Amok
*** 4.4 Further Examples of Recursion
*** 4.5 Designing Recursive Algorithms
Follows the following form:
- Test for base cases: (exit)
- Recur: It should make progress towards base case

*** 4.6 rEliminating Tail Recursion

** DONE 5 Array-based sequences
CLOSED: [2017-05-04 Thu 15:57]
*** 5.1 Python's Sequence Types
*** 5.2 Low-Level Arrays
*** 5.3 Dynamic arrays and amortization
*** 5.4 Efficiency of Python's sequence types
*** 5.5 Using Array-based sequences
*** 5.6 Multidimensional Data Sets

** 6 Stacks, Queues, and Deques
*** 6.1 Stacks
*** 6.2 Queues
*** 6.3 Double-ended Queues

** 7 Linked Lists
*** 7.1 Singly Linked Lists
*** 7.2 Circularly linked lits
*** 7.3 Doubly linked lits
*** 7.4 The positional list ADT
*** 7.5 Sorting a Positional List
*** 7.7 Link-based vs Array-based sequences

** DONE 8 Trees
CLOSED: [2017-05-04 Thu 17:20]
*** 8.1 General Trees
**** 8.1.1 General Tree Stuff
Tree: is an *abstract data type* that stores elements hierarchically. Except the root, each element has a *parent* and zero or more *children*.
Typically we call the *root* of the tree, and the other elements are connected to it.

Formal definition
A tree T is a set of nodes storing elements such that the nodes have a *parent-child* relationship.
- If T is nonempty, it has a special node called the *root* that has no parent.
- Each node v of T different grom the root has a unique *parent* node w; every node with a parent w is a child of w.
Note: According to def, tree can be empty. This allows us to define a tree recursively, such that a tree T is either empty or consists of a node r, called the root of T, and a set of subtrees whose roots are the children of r.

- *edge*: is a pair of nods (u,v) such that /u/ is the parent of /v/, or vice versa.

- *Internal Nodes*: Nodes that have children
- *External Nodes*: Nodes that are leafs, so don't have children.

**** 8.1.2 Tree Abstract Data Type
We define a tree ADT using the concept of a *position* as an abstraction for a node of a tree.
Position supports:
- p.element(): Return element stored at position p

- Tree ADT supports following *accessor methods*:
  + T.Root() : Returns position fo root in tree or None
  + T.is_root(p) : 
  + T.parent(p) : Returns position of parent or None
  + T.num_children(p) : Returns number of children
  + T.Children(p) : Generate an iteration of the children of p
  + T.is_leaf(p) : True if p doesn't have children
  + len(T) : Length
  + T.is_empty() : True if empty
  + T.positions() : Generate iteration fo all positions of T
  + iter(T) : Generate an iteration fo all elements stored in T

At this point, this book goes into defining a Tree Abstract Base Class in Python, which will be the base class for a lot of different Tree types (Binary search trees, etc) to reuse as much code as possible.
Provides definition for a nested *Position class* and a number of accessor methods. However, it does not define any internal representation for storing a tree.
There are 5 methods that remain abstract: 
root, parent, num_children, children, and __len__
Each method raises a NotImplementedError

**** 8.1.3 Computing Depth and Height
- Depth(p): If p is root, the depth is 0, otherwise, deph of p is 1 + depth(parent of p). This allows for a simple recursive algorithm.
- Height(p): If p is a leaf, then height is 0. Otherwise, height of p is 1 + max(height(children))
- Height of tree = Height of the root.

#+BEGIN_SRC python
def _height1(self):
    return max(self.depth(p) for p in self.positions() if self.is_leaf(p))
# Works in O(n^2)
#+END_SRC

#+BEGIN_SRC python
def _height2(self, p):
  if self.is_leaf(p): return 0
  else: return 1 + max(self._height2(c) for c in self.children(p))
# This runs in linear time
#+END_SRC

Better way:
#+BEGIN_SRC python
def height(self, p=None):
  if p is None:
    p = self.root()
  return self._height2(p)

#+END_SRC

*** 8.2 Binary Trees 
**** Definitions
Normal Definition:
A bt is an ordered tree with the following properties:
1. Every node has at most 2 childrem
2. each child is labeled as left child or right child
3. a left child precedes the right child in the order of children of a node.

Recursive Binary Tree Definition:
A tree is either empty of consists of:
- A node r, called the root of T, stores an element
- A BT (possibly empty), called the left subtree of T
- A BT (possibly empty), called right subtree of T

- Binary Tree Abstract Data Type can support:
  - T.left(p)
  - T.right(p)
  - T.sibling(p)

- *proper BT*: if each node has either 0 or 2 children

**** Properties of Binary Trees
Denoting all the nodes of same depth d as *level* d of T,
level 0 has at most 1 node, level 1 at most 2 nodes, etc. 
Thus, *level d* has at most 2^d nodes

Proposition 8.8: Let T be nonempty BT. n=# nodes, ne=# of external nodes, ni=# internal nodes, and h=height of T.
Then:
- h+1 <= n <= 2^(h+1) - 1
- 1 <= ne <= 2^h
- h <= ni <= 2^h - 1
- lof(n+1 - 1 <= h <= n-1 

Proposition 8.9: In nonempty *proper* bt T: ne = ni+1

*** 8.3 Implementing Trees
**** 8.3.1 Linked List Representation
We all know what it is. It's the most commong way of representing Trees.
Summary of performance of this implementation:
- len: LinkedBinaryTree uses an isntance variable to store numer of nodes of T. Takes O(1)
- is_empty: inherited from Tree,relies on a single call to len, so O(1) as well.
- root, left, right, num_children from Tree run in O(1), same as is_root (which calls root)
- depth(p) in O(dp + 1)
- height runs in O(n)
- add_root, add_left, add_right, replace, delete, attach all run in O(1)
SEE CODE OF IMPLEMENTATION in repository

**** 8.3.2 Array-Based Representation
Alternative representation based on array (though in Python we will use lists)
For very position p of T, let f(p) be the integer defined as follows:
- if p is in the root of T, then f(p) = 0
- if p is the left child of position q, then f(p) = 2f(q)+1
- if p is the right child of position q, then f(p) = 2f(q)+2
f function is known as *level numbering* of positions in a binary tree T.

Advantages:
Position p can be represented by a single integer.
Position-based methods such as root, parent, left, right can be implemented using arithmetic.
left child = 2f(p) + 1
parent = floor((f(p)-1)/2)

Considerations:
- Space usage can be a problem. Depends of the shape of the tree. If it is not *full* there would be a lot of empty cells. The worst case is N = 2^n -1 (N is length of array) Note: the array A requires length N = 1+fm (where N is length, and fm is the maximum value of f(p)).
- Some update operations are not efficient. Like *delete* and *promoting* take O(n), because all descendants need to move within the array.

It is of great usefulness in certain cases, though, like in *"heaps"*

**** 8.3.4 Linked Structure for General Trees:
Same, just have a *container* to store references to children. Like a Python list for example.

*** 8.4 Tree Traversal Algorithms
**** 8.4.1 Preorder and postorder Traversal for general trees
- Preorder: root is visited first. Then the subtrees rooted at its children are traversed recursively. If the tree is ordered, then subtrees are traversed according to the order of the children. Like a Book Index.
- Postorder: Recursively traverses subtrees rooted at the children of the root first, then it visits the root.

Running-Time Analysis
Both are efficient ways to access all the positions of a tree. At each position p, the nonrecursive part requires constant O(cp+1) time, making the traversal be O(n), where n is the number of positions in the tree.

**** 8.4.2 Breadth-first for general trees too
Another traversing approach, is to go visit all the positions of level (or depth) d, before visiting the next level (or depth) d+1.
This approach is commong in software for playing games, to represent the possible choices of moves.

Algorithm: It is not recursive. Instead think of using a  *Queue*. While queue is not empty, p = deque, visit(p), then for all the children of p, enqueue them.
 
**** 8.4.3 Inorder traversal for binary tree
The previous ways of traversing could be applied to general trees because they don't require an order. 
#+BEGIN_SRC python
def inorder(p):
  if p.left:
    inorder(p.left)
  visit(p)
  if p.right:
    inorder(p.right)

#+END_SRC

***** Binary Search Trees
Let S be a set of unique elements with an order relation.
- Position p stores element of S, denoted as e(p)
- Elements in left subtree of p, are less than e(p)
- Elements in right of subtree of p, are greater than e(p)
It can be viewed as a *binary decision tree*

**** 8.4.4 Implementing tree traversals in Python
Remember that when defining the Tree ADT, we stated T should include support for:
- T.positions(): To generate an iteration of all positions
- iter(T): To generate all elements stored within the tree T

**** 8.4.5 Applications of Tree Traversals
- To indent! Like book table of contents or label 
- Parenthetic string representations P(T)
  1) if T consists of only 1 single position:
       P(T) = str(p.element())
  2) else: 
       P(T) = str(p.element()) + '(' + P(T1) + ', ' + ... + ', ' + P(Tk) + ')' 
Example:
Electronics R’Us (R&D, Sales (Domestic, International (Canada,
S. America, Overseas (Africa, Europe, Asia, Australia))),
Purchasing, Manufacturing (TV, CD, Tuner))

*** Case Study: An Expression Tree

** TODO 9 Priority Queues
*** 9.1 The Priority Queue Abstract Data Type
**** Priorities
Collection of prioratized elements that allows arbitrary element insertion, and the removal of element with first priority.
When element is added to PQ, it is associated with a *key*. The elements with lowest *key* values are removed first.

**** Priority Queue ADT
The following is the PQ ADT modeled as key-value pair.

| P.add(k, v)    | Insert item with key k and value v          |
| P.min()        | return tuple (k,v) but don't removed        |
| P.remove_min() | Remove and return item with min key from PQ |
| P.is_empty()   | True of P is empty                          |
| len(P)         | return # items in P                         |

In Section 9.5, we consider keys with changing values.

*** 9.2 Implementing Priority Queue
**** 9.2.1 The Composition Design Patter
To keep track of elements in our data structure, in this case the element and its key, even as they are relocated within the ds.
We can define a _Item class to ensure that each element remains paired.
In PQ, we use *composition* to store items internally as pairs.
View code priority_queue_base.py

**** Implementation with Unsorted list
Storing entries in unsorted list, key-value pairs are represented as composites. This items are stored within a PositionalList, identified as the _data member of the class.

How it works: When adding an element,a new _Item composite is created and its added to the end of the list. Taking O(1).
Min() and remove_min() must locate item so they take O(n)
Analysis:
| len, is_empty, add | O(1) |
| min, remove_min    | O(n) |

**** Implementation with Sorted list
Another implementation using a positional list, is to maintain entries sorted by non-decreasing keys.
In this case the analysis of running times:
| len, is_empty, min, remove_min | O(1) |
| add                            | O(n) |

*** 9.3 Heaps
A difference with the other 2 strategies for implementing a priority queue in which there are trade-offs for running times. This section provides a more efficient realization using: *binary heaps*.

*Binary heap* allows perform insertions and removals in logarithmic time. This improvement is acchieved by using a *binary tree* structure to find a compromise between elements being entirely unsorted or perfectly sorted.

**** 9.3.1 Heap Data Structure
*Heap* is a binary tree T that stores a collection of items at its positions with 2 additional properties:
- a *relational property* defined in the way keys are stored in T
- a *structural property* defined in terms of the shape of T

*Relational Property: Heap-Order Property*
In a heap T, for every position p other than the root, the key stored at p is greater or equal than the key stored at p's parent.
T.key(p) >= T.key(T.parent(p))
- keys stored in nondecreasing order while traversing to leaves.
- minimum key always at top
- better if height of heap tree is small as possible.

*Structural Property: Complete Binary Tree Property*
A heap T with height h is a *complete* binary tree if levels 0,1,..h-1 have the max number of nodes. In other words, all levels but the last one are full.

*The Height of a Heap*
Proposition 9.2: A heap T storing n entries has height h = floor(logn)

**** 9.3.2 Implementing a PQ with a Heap


**** 9.3.3 Array-Based representation of Complete Binary Tree

**** 9.3.3 Python Heap Implementation

**** 9.3.7 Python's heapq Module

*** 9.4 Sorting with a Priority Queue
**** Selection-sort and Insertion-sort
**** Heap-sort 

*** 9.5 Adaptable Priority Queues

** 10 Maps, Hash Tables, and Skip Lists
*** 1 Maps and Dictionaries
*** 2 Hash Tables
*** 3 Sorted Maps
*** 4 Skip Lists
*** 5 Sets, Multisents, and Multimaps

** 11 Search Trees 
*** 1 Binary Search Trees
*** 2 Balanced Search Trees
*** 3 AVL Trees
*** 4 Splay Trees
*** 5 (2,4) Trees
*** 6 Red-Black Trees

** 12 Sorting and Selection
*** 12.2 Merge-Sort
*** 12.3 Quick-Sort
*** 12.4 Studying Sorting through an Algorithmic Lens
*** 12.5 Comparing Sorting Algorithms
*** 12.6 Python's Built-in sorting functions
*** 12.7 Selection

** 13 Text Processing
*** 13.1 Abunadnce of Digitized Text
*** 13.2 Pattern-matching algorihtms
*** [#A] 13.3 Dynamic Programming
*** 13.4 Text Compression and the Greedy Method

** 14 Graph Algorithm
*** 14.1 Graphs
*** 14.2 Data structures for graphs
*** 14.3 Graph Traversals
*** 14.6 Shortest Paths
*** 14.7 Minimum Spanning Trees
**** 14.7.1 Prim-jarnik Algorithm
**** 14.7.2 Kriskal's Algorithm
**** 14.7.3 Disjoint Partitions and Union-Find Structures

** 15 Memory Management and B-Trees
Computer systems are greatly impacted by the management of the computer's memory system. This book talks about *ways in which memory is allocated and deallocated during execution* and the impact in performance. Then, the *complexity of multilevel memory hierarchies* in systems. Finally, *use of classic data structures and algorithms used to manage memory*, and how the use of memory hierarchies impacts choice of data structures and algorithms.

*** 15.1 Memory Management
Computer memory is organized into a sequence of *words*, of typical sizes: 4, 8, 16 bytes. Memory words numbered from 0 to N-1, where N is the number of memory words available in the computer.
- Memory address: number associated with each mem word.
So memory of computer can be seen as giant array of memory words.

**** 15.1.1 Memory allocation
In Python, all objects are stored in a pool of memory called *memory heap* or *Python heap* (not same as ds heap).
- *blocks*: storage available is divided into contiguous array-like chuncks of memory.
System must quickly allocate memory for new objects.
- *free list*: method to keep contiguous holes of available memory in a linked list.
- *fragmentation*: separation of unused memory into diff holes. Becomes a problem bc makes it harder to find large contiguous chunks of free space. Goal: minimize fragmentation.
Types of fragmentation: Internal and External.
- Internal: portion of allocated memory block is unused. ie array of size 1000, but only 100 cells contain values. (Not much run-time env can do...)
- External: significant amount of unused memory between many blocks of allocated memory..So run-time env should allocate memory in a way to try to reduce external fragmentation.
Herustics for allocating memory from the heap:
- Best-fit algorithm: searches entire free list to find hole whose size is closes to amount of mem requested.
- First-fit algorithm: searches from beginning for first hole large enough.
- Next-fit algorithm: similar to first-fit, but begins search where it left off previously. (Like circular ll)
- Worst-fit algorithm: searches free list to find largest hole of available memory.
In each algorithm, the requested amount of memory is subtracted from the chosen memory hole and the leftover part of that hole is returned to the *free list*.
Best-fit -> produces worst fragmentation,since leftover parts are tiny. The first-fit is fast, but produces a lot of fragmentation in the front of the list. The next-fit fixes that by spreading fragmentation eavenly, but still makes it hard to allocate large blocks. Worst-fit attempts to avoid this by keeping contiguous sections of free memory as large as possible.

**** 15.1.2 Garbage collection
Other languages: memory space for objects must be explicitly deallocated by programmer. 
In Python: interpreter does the memory management.
- *Garbage collection*: process of detecting "stale" objects, deallocated their space, and returning reclaimed space to *free list*

Definitions for garbage collection:
- *Live objects*: program has direct or indirect reference to such object.
- *Direct reference*: to an object is identifier in active namespace (ie global namespace or local namespace for active function).
- *root objects*: objects with direct references (like w = Widget(), w is in current namespace.
- *indirect reference*: reference that occurs withing state of some other live object. ie if widget object maintains a list attribute. That list is a live obj.
Python deallocate any object that is not considered *live obj*. Python uses 2 strategies: Reference counts & Cycle Detection.

***** Reference Counts
Every Python object has integer called *reference count*. This is the count of how many references to this object exist anywhere in the system. 
Increases when reference is assigned to object.
Decreases when reference is reassigned to something else.
- Python allows programs to see object's ref count. Using *sys* module, function called *getrefcount*.
Whenever ref count is 0, object is deallocated.

***** Cycle Detection
Some objects with nonzero ref counts may be live. For isntance, if a group of objects have references to each other, but are not reachable from a root object.
Every so often, especially when memory heap is running out of space, the interpreter runs certain algorithms to reclaim memory. A classic algo is *mark-sweep*.
- *Mark-Sweep Algorithm*: This algorithm associates a "mark" bit with each object that identifies whether obj is alive. When garbage collection seems needed, it suspends all other activity and clear themark bits of all the objects currently in mem heap. Then, go through active namespace and mark all root objects as live. Then, perform *deph-first* search on directed graph defined by objects referencing other objects. So objects = vertex and reference = directed edge. Once all objects marked, scan through heap and reclaim space from objects not marketd. Optionally coalesce all allocated space into a single block.
- Performing DFS In-Place: Note that since the goal is to reclaim unused space, algorith must not use extra space during garbage collection. So no recursive. DFS using only a constant amount of additional space.

**** 15.1.3 Additional memory used by interpreter
***** The Run-Time Call Stack
Stacks = Super important in run-time env of python programs.
- *Call stack (Python interpreter stack)*: Private stack of a running program in python. Keeps track of nested sequence of currently active invocations of functions.
- *Activation record (frame)*: each entry of stack. Stores important info about the func invoked.
- *Running Call*: activation record of  function that is being executed is at top of stack. All others are *suspended calls*
- Each activation record has dictionary with local namespace for that call.
- Also has a reference to the function definition itself, and a variable called *program counter* , to maintain the address of the statement within the function. This is used by the interpreter when a suspended function becomes active.

***** Operand Stack
In arithmetic operations, the interpreter uses the operand stack.

*** 15.2 Memory Hierarchies and Caching
**** Memory Systems
Hierarchy: CPU, Registers, Caches, Int memory, Ext memory, network storage.

**** Caching Strategies
Most algorithms are not designed with memory hierarchy in mind, in spite of the great variance between access times.
A justification is that, it wouldn't be device independent, and such optimizations are not always necessary.
- Caching: bringing data into primary memory (motivated by temporal locality), expecting that to be used again soon.
- Blocking: (motivated by spatial locality) bringing a chunk surrounding l (location needed), expecting locations nearby to be accessed soon.
Blocks in between cache memory & internal memory: *cache lines*.
- Blocks between internal memory & external memory: *pages*.

*** 15.3 External searching and B-trees
- *disk blocks*: secondary memory blocks
- *disk transfer*: transfer of a block from secondary to primary memory.
Goal: minimize # of disk transfers needed to perform a query or update. Such count known as *I/O complexity*.
**** 15.3.1 (a,b) Trees
**** 15.3.2 B-Trees

*** 15.4 External-Memory Sorting
**** 15.4.1 Multiway merging

* Fundamental Techniques (from Algorithm Design - Goodrich book)
Actually they are also in this Book!!!
** The Greedy Method
** Divide and Conquer
** Dynamic Programming

* Algorithm Design Patterns in this book
** Algorithm design patterns: 
*** Recursion (chapter 4)
*** Dynamic programming (section 13.3)
*** The Greedy method (sections 13.4.2, 14.6.2, 14.7)
*** Divide and conquer (section 12.2.1)

** Software Engineering Design Patterns:
*** Template Method 
*** Position (Sections 7.4 and 8.1.2)
*** Composition (Sections 7.6.1, 9.2.1, and 10.1.4)
*** Template method (Sections 2.4.3, 8.4.6, 10.1.3, 10.5.2, and 11.2.1)
*** Locator (Section 9.5.1)
*** Factory method (Section 11.2.1)
draw trees in org mode emacs
* New Things I learned
** Duck typing: Trying something and handling exceptions if they occur. (As long as long as it quacks, treat it like a duck, otherwise treat differently)

#+BEGIN_SRC python
class Person:
    def help(self):
        print("Heeeelp!")

class Duck:
    def help(self):
        print("Quaaaaaack!")

class SomethingElse:
    pass

def InTheForest(x):      # Here, passing any object
    x.help()             # and calling its help() method.
# This either works differentl for each object or gives runtime error

donald = Duck()
john = Person()
who = SomethingElse()

for thing in [donald, john, who]:
    try:
        InTheForest(thing)
    except AttributeError:
        print 'Meeowww!'

#+END_SRC

- Abstract Base Class: ABC cannot be instantiated. But defines one or more common methods that all implementations of the abstraction *must* have.
- Concrete classes inherit from ABC and provide implementations for the methods declared by the ABC.

** Composition design patter (Section 7.6 and 9.2)
Defining an _Item class to ensure that each element remained paired with its associated count in the primary data structure.

* HW Solutions
** Ch 8
1) root is the node without parents, internal nodes have children, cs016 has 9 descendants, and one ancestor. depth of the node paper is 3. height of tree is 4.
2) a linear tree
3) Proposition 4: Heigh of nonempty tree is equal to the maximum of the depths of its leaf positions. Because the height of tree is = to the height of the root. Which by the definition is one more than the maximum of the heights of its children. and the max height of the children is the max depth of a leaf.
5) Given a T. Recurse the tree in order. For node in T.inorder(): if T.right(node) is None and T.left(node) is not None and not T.children(T.left(node)) count += 1
6) 
